注：读 <Mysql技术内幕> 有感
一：数据库定义
    数据库与数据库实例：数据库是一系列以一种特殊的数据结构存储的文件，而数据库实例才是真正操作数据库文件的。实例是由数据库后台进程/线程以及一个共享内存区组成

二：MySQL表存储引擎
    InnoDB存储引擎
   1.支持事务，主要应用于在线事务处理（OLTP）,特点是：行锁设计，支持外键，支持类似于Oracle的非锁定读，
      即默认情况下读取操作不会产生锁，是windows下的默认存储，其他系统下是用mysql官方指定的MyISAM,
    InnoDB将数据放在一个逻辑的表空间中，由InnoDB自己管理。可以将每个InnoDB存储引擎的表单独存放到
      一个独立的ibd文件中，对于表中数据的存储，InnoDB采用了聚集的方式，类似于oracle的索引聚集表，
      每张表的存储都按主键的顺序存放，如果没有显示的在表定义时指定主键，引擎会为每一行生成一个6字节的ROWID,
      并以此作为主键

    2.MyISAM存储引擎：
    是官方提供的存储引擎，不支持事务，表锁和全文索引。对于OLAP(在线分析处理)操作速度快，是除了windows版本外
      所有的mysql的默认引擎，MyISAM表由MYI和MYD组成，MYD用来存放数据文件，MYI用来存放索引文件

    3.Memory存储引擎：
     又称为（HEAP存储引擎），将数据存放在内存中，如果数据库重启或者奔溃，那么数据都消失，适合用于
      存储临时数据的临时表，默认使用哈希索引，而不是B+树索引，存储引擎速度非常快，但只支持表锁，并发性能较差

三：InnoDB 和 MyISAM 比较
    数据存储形式：InnoDB将它的表和索引存在一个逻辑表空间中，MyISAM将数据和索引文件分开。
    InnoDB的数据文件本身就是索引文件，而MyISAM因为索引文件与数据是分开的，同时索引文件中仅保存数据文件的地址
    两者数据存储都是B+Tree，因此InnoDB叶子节点上存放的是完整的数据记录（这种索引叫做聚集索引，具体结构见：
    innodb主键索引tree.png），
    而MyISAM存放的是指向地址（指针或者？），同时InnoDB辅助索引data区（叶节点）存储该记录主键的值，而不是地址
    (具体结构见：innodb辅助索引tree.png)
    因此辅助索引搜索需要检索两遍，首先检索辅助索引获得主键，然后用主键到主索引中检所获得记录。

四：锁
    表锁和行锁：
        InnoDB的行锁是针对索引加的锁，不是针对记录加的锁。并且该索引不能失效，否则就会从行锁升级为表锁。
        也就是说，如果不是针对索引进行的更新或者新增这些操作，都会使用表锁

        注意：
            也就是在 指标 项目中，本来是 update全表数据，但是同时使用的是id去查找，此时虽然使用的是索引，在mysql
            看来会大量使用行锁，导致事务执行效率低，可能造成其他事务长时间等待或锁冲突，所以mysql会将行锁升级为
            表锁，并没有使用索引

        表锁：
            是mysql中最基本的锁策略，开销最小，会锁住整张表，一个用户对表进行写操作，会阻塞所有的读写操作。表锁
            是mysql服务器层实现的

        行锁：
            最大程度支持并发处理，针对行索引锁定，开销最大，行锁是底层 innoDB存储引擎实现的


    读写锁：
         在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决问题，如一个人正在读取一个邮件表
          记录，另外一个用户试图删除编号为25的邮件，此时会出现数据读取问题。
         解决办法：
              并发控制，在处理并发读或者写时，可以通过实现一个由两种类型的锁组成的锁系统来解决。通常称为共享锁
              （shared lock）和排他锁（exclusive lock）.也叫读锁（read lock）和写锁（write lock）
             读锁是共享的，互不阻塞。写锁是排他的，也就是一个写锁会阻塞其他的写锁和读锁，安全策略的考虑，只有这
              样才能保证在给定的时间内，只有一个用户能执行写入，并防止其他用户读取正在写入的统一资源。

    多版本并发控制：MVCC（快照）
         MVCC是行级锁的一个变种，在很多情况下避免了加锁，因此开销更低。大都实现了非阻塞的读操作，写操作也只锁定
         必要的行。
         MVCC的实现，是通过保存数据在某个时间点的快照来实现。也就是说，不管需要执行多长时间，每个事务看到的数据
         都是一致的，根据事务开始的时间不同，每个事务对同一张表，同一时刻看到的数据可能是不一样的。
            理解：其实快照就是某个时间点之前的数据，该数据为历史数据，因此在这个时间节点上，对所有的事务来说，
            数据都不会改变，因此每个事务看到的数据都是一致的。如果事务开始时间不同，可能就跨了两个或多个快照时间
            节点，此时两份数据可能不一样。

         InnoDB的 MVCC,是通过每行记录后面保存两个隐藏的列来实现。一个保存了行的创建时间，一个保存行的过期时间
         （或删除时间）。存储的不是实际的时间值。而是事务版本号，每开始一个新的事务，系统版本号就会自动递增。
         事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。（只在不可重复读和
         可重复读下才生效）
         如：
            SELECT
                1.innoDB 只查找版本早于当前事务版本的数据行，也就是说行的系统版本号小于或者等于事务的系统版本号，
                可以确保事务读取的行，要么是在事务开始前，要么是事务自身插入或者修改过的
                2.行的删除版本要么未定义，要么大于当前事务版本号，可以确保事务读取到的行，在事务开始之前未被删除
                符合这两者的记录，才能作为查询结果返回

            INSERT
                innoDB为新插入的行保存当前系统版本号作为行版本号

            DELETE
                innoDB为删除的行保存当前系统版本号作为行版本号

            保存这两个额外系统版本号，使大多数操作都不需要加锁，性能更好，不足之处就是增加了存储以及维护两个字段的
            成本。
            MVCC只在 REPEATABLE_READ 和 READ_COMMITTED 两个级别下工作，因为 READ UNCOMMITTED 总是读取最新数据，而
            不是符合当前事务版本的数据行，而 SERIALIZABLE 则会对所有读取的行加锁

    间隙锁：next key
        通过间隙锁，锁定某一范围内的行，防止新增该范围内的记录，防止幻读。此方法是实时读


总结：
    一致性非锁定读  【https://www.jianshu.com/p/45900fe75e51】
    一致性非锁定读指的是：要读取的行被加了X锁（排它锁），这时候读取操作不会等待行上锁的释放，而是会读取行的一个
    快照数据。
    1.在RR和RC隔离级别下一致性非锁定读是innodb默认的模式，一致性读不会加任何锁，不影响其他事务来修改相关数据

    需要注意的一些点：
    ①每行记录可能有多个版本
    ②在事务隔离级别READ COMMITTED （简写RC）和 REPEATABLE READ（简写RR）下，InnoDB存储引擎使用一致性非锁定读
    。但是对快照的定义却不相同。
    在RC下，一致性非锁定读总是读取被锁定行的最新一份快照数据。而在RR级别下，总是读取事务开始时的数据版本。


    MVCC在MySQL的InnoDB中的实现  【https://www.cnblogs.com/hongdada/p/12505896.html#2873964246】
    在InnoDB中，会在每行数据后添加两个额外的隐藏的值来实现MVCC，这两个值一个记录这行数据何时被创建，另外一个记录
    这行数据何时过期（或者被删除）。 在实际操作中，存储的并不是时间，而是事务的版本号，每开启一个新事务，事务的
    版本号就会递增。 在可重读Repeatable read事务隔离级别下：

    SELECT时，读取创建版本号<=当前事务版本号，删除版本号为空或>当前事务版本号。
    INSERT时，保存当前事务版本号为行的创建版本号
    DELETE时，保存当前事务版本号为行的删除版本号
    UPDATE时，插入一条新纪录，保存当前事务版本号为行创建版本号，同时保存当前事务版本号到原来删除的行
    通过MVCC，虽然每行记录都需要额外的存储空间，更多的行检查工作以及一些额外的维护工作，但可以减少锁的使用，
    大多数读操作都不用加锁，读数据操作很简单，性能很好，并且也能保证只会读取到符合标准的行，也只锁住必要行。


    快照读：就是select
    select * from table ….;
    当前读：特殊的读操作，插入/更新/删除操作，属于当前读，处理的都是当前的数据，需要加锁。
    select * from table where ? lock in share mode;
    select * from table where ? for update;
    insert;
    update ;
    delete;

五：日志
    一：事务日志：
        事务日志可以帮助提高事务的效率。使用事务日志，存储引擎在修改表的数据时，只需要修改其内存拷贝，再把该修改行为
        记录到持久在硬盘上的事务日志中。而不用每次都将修改的数据本身持久到磁盘。事务日志采用的是追加的方式，因此写日志
        的操作是磁盘上一小块区域内的顺序I/O,而不像随机 I/O 需要在磁盘的多个地方移动磁头，所以采用事务日志的方式相对来
        说要快得多。事务日志持久之后，内存中被修改的数据在后台可以慢慢的刷回到磁盘。称为：预写式日志，修改数据需要写
        两次磁盘。

        如果数据修改已经记录到事务日志并持久化，数据本身未写回磁盘，此时系统崩溃。存储引擎在重启时，能自动恢复这部分
        修改的数据

   二：隐式和显示锁定
        InnoDB采用的是两阶段锁定协议，在事务执行过程中，随时都可以执行锁定，锁只有在执行 COMMIT 以及 ROLLBACK的时候
        才会释放，并且所有的锁是在同一时刻被释放。这些都是隐式锁定，InnoDB会根据隔离级别在需要的时候自动加锁











