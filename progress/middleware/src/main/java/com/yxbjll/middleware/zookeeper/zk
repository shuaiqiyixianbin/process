一：zookeeper
    相关博客：https://mp.weixin.qq.com/s/gphDLJMO3QcRoN3zkco4EA
    概括：
        zooKeeper主要服务于分布式系统，可以用ZooKeeper来做：统一配置管理、统一命名服务、分布式锁、集群管理。
        使用分布式系统就无法避免对节点管理的问题(需要实时感知节点的状态、对节点进行统一管理等等)，而由于这
        些问题处理起来可能相对麻烦和提高了系统的复杂性，ZooKeeper作为一个能够通用解决这些问题的中间件就应运而生了。

        ZooKeeper的数据结构，跟Unix文件系统非常类似，可以看做是一颗树，每个节点叫做ZNode。每一个节点可以通过路径来标识

                        /(node)
                        |
                        |
 /java/spring(node)<-- /java(node) --> /java/mq(node)
                        |
                        |
                /java/zk(node)

        ZooKeeper的节点我们称之为Znode，Znode分为两种类型：

        1）临时(Ephemeral)：当客户端和服务端断开连接后，所创建的Znode(节点)会自动删除
        2）持久(Persistent)：当客户端和服务端断开连接后，所创建的Znode(节点)不会删除

        ZooKeeper和Redis一样，也是C/S结构(分成客户端和服务端)

        1.1 监听器
        在上面我们已经简单知道了ZooKeeper的数据结构了，ZooKeeper还配合了监听器才能够做那么多事的。
        常见的监听场景有以下两项：

        1.1.1：监听Znode节点的数据变化（数据发布与订阅，即所谓的配置中心）
            发布/订阅系统一般有两种设计模式，分别是推（Push）和拉（Pull）模式。
                  - 推模式
                      服务端主动将数据更新发送给所有订阅的客户端
                  - 拉模式
                      客户端主动发起请求来获取最新数据，通常客户端都采用定时轮询拉取的方式

            ZooKeeper 采用的是推拉相结合的方式：
                客户端向服务端注册自己需要关注的节点，一旦该节点的数据发生变更，那么服务端就会向相应
            的客户端发送Watcher事件通知，客户端接收到这个消息通知后，需要主动到服务端获取最新的数据


        1.1.2：监听子节点的增减变化

        1.2：实现功能：
            1.2.1：分布式锁原理
                我们可以使用ZooKeeper来实现分布式锁，那是怎么做的呢？？下面来看看：

                系统A、B、C都去访问locks节点
                访问的时候会创建带顺序号的临时/短暂(EPHEMERAL_SEQUENTIAL)节点，比如，系统A创建了id_000000节点，
                系统B创建了id_000002节点，系统C创建了id_000001节点。

                创建出临时带顺序号的节点
                接着，拿到/locks节点下的所有子节点(id_000000,id_000001,id_000002)，判断自己创建的是不是最小的那个节点
                如果是，则拿到锁。
                释放锁：执行完操作后，把创建的节点给删掉
                如果不是，则监听比自己要小1的节点变化

                举个例子：
                系统A拿到/locks节点下的所有子节点，经过比较，发现自己(id_000000)，是所有子节点最小的。所以得到锁
                系统B拿到/locks节点下的所有子节点，经过比较，发现自己(id_000002)，不是所有子节点最小的。所以监听比自己小1的节点id_000001的状态
                系统C拿到/locks节点下的所有子节点，经过比较，发现自己(id_000001)，不是所有子节点最小的。所以监听比自己小1的节点id_000000的状态
                ……
                等到系统A执行完操作以后，将自己创建的节点删除(id_000000)。通过监听，系统C发现id_000000节点已经删除了，发现
                自己已经是最小的节点了，于是顺利拿到锁
                ….系统B如上