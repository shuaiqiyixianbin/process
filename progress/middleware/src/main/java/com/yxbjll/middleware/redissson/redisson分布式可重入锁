一：使用redis锁的问题
    1.1：当业务代码未执行完，锁过期
         使用redisson实现分布式锁，可以对锁进行续期

    1.2:redisson分布式锁原理：【https://blog.csdn.net/lzhcoder/article/details/88387751】
     1.2.1：如何实现锁的续期
            如果负责存储这个分布式锁的Redisson节点宕机以后，此时如果这个锁正好处于锁住的状态时，这个锁就会出现
            锁死的状态。为了避免这种情况的发生，Redisson内部提供了一个监控锁的看门狗，它的作用是Redisson实例被
            关闭前，不断地延长锁的有效期。默认情况下，看门狗的检查锁的超时时间是30s,也可以通过 Config.lockWatchdogTimeout
            来指定

            如何回答
            默认情况下,加锁的时间是30秒.如果加锁的业务没有执行完,那么到 30-10 = 20秒的时候,就会进行一次续期,
            把锁重置成30秒.那这个时候可能又有同学问了,那业务的机器万一宕机了呢?宕机了定时任务跑不了,就续不了期
            ,那自然30秒之后锁就解开了呗.


     1.2.2:加锁机制（底层实现是基于 lua 脚本，通过脚本实现原子性）

         "if(redis.call('exists',KEYS[1]) == 0) then"+
                   "redis.call('hset',KEYS[1],ARGV[2],1);"+
                    "redis.call('pexpire',KEYS[1],ARGV[1]);"+
                     "return nil;"+
         "end;"+

         "if(redis.call('hexists',KEYS[1],ARGV[2]) == 1) then"+
              "redis.call('hincrby',KEYS[1],ARGV[2],1);"+
               "redis.call('pexpire',KEYS[1],ARGV[1]);"+
                "return nil;"+
         "end;"+

         "return redis.call('pttl',KEYS[1]);"

         KEYS[1]代表的是你加锁的那个key，比如说：
         RLock lock = redisson.getLock("myLock");
         这里你自己设置了加锁的那个锁key就是“myLock”。
         ARGV[1]代表的就是锁key的默认生存时间，默认30秒。
         ARGV[2]代表的是加锁的客户端的ID，类似于下面这样：

         8743c9c0-0795-4907-87fd-6c719a6b4586:1

         第一段if判断语句，就是用“exists myLock”命令判断一下，如果你要加锁的那个锁key不存在的话，你就进行加锁。
         如何加锁呢？很简单，用下面的命令：
         hset myLock
             8743c9c0-0795-4907-87fd-6c719a6b4586:1 1

         通过这个命令设置一个hash数据结构，这行命令执行后，会出现一个类似下面的数据结构：
         上述就代表“8743c9c0-0795-4907-87fd-6c719a6b4586:1”这个客户端对“myLock”这个锁key完成了加锁。
         接着会执行“pexpire myLock 30000”命令，设置myLock这个锁key的生存时间是30秒。
         好了，到此为止，ok，加锁完成了。


     1.2.2：锁互斥机制
         那么在这个时候，如果客户端2来尝试加锁，执行了同样的一段lua脚本，会咋样呢？
         很简单，第一个if判断会执行“exists myLock”，发现myLock这个锁key已经存在了。
         接着第二个if判断，判断一下，myLock锁key的hash数据结构中，是否包含客户端2的ID，但是明显不是的，因为那里包含
         的是客户端1的ID。
         所以，客户端2会获取到pttl myLock返回的一个数字，这个数字代表了myLock这个锁key的剩余生存时间。比如还剩15000
         毫秒的生存时间。
         此时客户端2会进入一个while循环，不停的尝试加锁。

     1.2.3：watch dog自动延期机制
         客户端1加锁的锁key默认生存时间才30秒，如果超过了30秒，客户端1还想一直持有这把锁，怎么办呢？
         简单！只要客户端1一旦加锁成功，就会启动一个watch dog看门狗，他是一个后台线程，会每隔10秒检查一下，如果
         客户端1还持有锁key，那么就会不断的延长锁key的生存时间。

     1.2.4：可重入加锁机制
         那如果客户端1都已经持有了这把锁了，结果可重入的加锁会怎么样呢？
         这时我们来分析一下上面那段lua脚本。

         第一个if判断肯定不成立，“exists myLock”会显示锁key已经存在了。
         第二个if判断会成立，因为myLock的hash数据结构中包含的那个ID，就是客户端1的那个ID，也就是“8743c9c0-0795-4907-87fd-6c719a6b4586:1”
         此时就会执行可重入加锁的逻辑，他会用：
         incrby myLock
            8743c9c0-0795-4907-87fd-6c71a6b4586:1 1
         通过这个命令，对客户端1的加锁次数，累加1。
         此时myLock数据结构变为下面这样：
            8743c9c0-0795-4907-87fd-6c71a6b4586:1 2
         大家看到了吧，那个myLock的hash数据结构中的那个客户端ID，就对应着加锁的次数

     1.2.5：释放锁机制
         如果执行lock.unlock()，就可以释放分布式锁，此时的业务逻辑也是非常简单的。
         其实说白了，就是每次都对myLock数据结构中的那个加锁次数减1。
         如果发现加锁次数是0了，说明这个客户端已经不再持有锁了，此时就会用：
         “del myLock”命令，从redis里删除这个key。
         然后呢，另外的客户端2就可以尝试完成加锁了。
         这就是所谓的分布式锁的开源Redisson框架的实现机制

     以上就是基于Redisson实现分布式锁，本质通过redis的 lua脚本，在某一台服务器上构建锁，然后通过一系列的方式如
     冲入 +1 等方法实现。

