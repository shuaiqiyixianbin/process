一：netty基础
    1.1：阻塞(Block)和非阻塞(NonBlock)
         阻塞：
            进程在访问数据的时候，如果数据没有准备好，需要等待缓冲区中的数据准备好后才处理其他事情，否则一直等待
         非阻塞：
            进程访问数据缓冲区的时候，如果数据没有准备好则直接返回，不会等待。如果数据准备好了，也直接返回。

         阻塞调用是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。
         非阻塞调用指在不能立刻得到结果之前，该调用不会阻塞当前线程。

    1.2：同步(Synchronization)和异步(Async)的方式
         同步:
            应用程序直接参与 IO 读写的操作。
         异步：
            所有的 IO 读写交给操作系统去处理，应用程序只需要等待通知

        同步方式在处理IO事件的时候，必须阻塞在某个方法上面，等待我们的IO事件完成(阻塞IO事件或者通过轮询IO事件的方式）.
        对于异步来说，所有的IO读写都交给了搡作系统。这个时候，我们可以去做其他的事情，并不拓要去完成真正的IO搡作，当
        搡作完成IO后.会给我们的应用程序一个通知

        同步：阻塞到IO事件，阻塞到read成则write。这个时候我们就完全不能做自己的事情，让读写方法加入到线程里面，然后
        阻塞线程来实现，对线程的性能开销比较大，


    1.3: IO 和 NIO 区别：
        1）面向流与面向缓冲
        Java NIO和IO之间第一个最大的区别是，IO是面向流的.NIO是面向缓冲区的。Java IO面向流意味着毎次从流中读一个或
        多个字节，直至读取所有字节，它们没有被缓存在任何地方，此外，它不能前后移动流中的数据。如果需要前后移动从流中
        读取的教据，需要先将它缓存到一个缓冲区。Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，
        霱要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。

        2）阻塞与非阻塞
        Java IO的各种流是阻塞的。这意味着，当一个线程调用read() 或 write()时，该线程被阻塞，直到有一些数据被读取，
        或数据完全写入。该线程在此期间不能再干任何事情了。 Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据
        ，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据
        变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要
        等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞IO的空闲时间用于在其它通道上执行IO操作，
        所以一个单独的线程现在可以管理多个输入和输出通道（channel）。

        3）选择器（Selector)
        Java NIO的选择器允许一个单独的线程来监视多个输入通道，你可以注册多个通道使用一个选择器，然后使用一个单独的
        线程来“选择"通道：这些通道里已经有可以处理的输入，或者选择已准备写入的通道。这选择机制，使得一个单独的线程
        很容易来管理多个通道。

        4）NIO和BIO读取文件
           BIO从一个阻塞的流中一行一行的读取数据
           NIO通道是数据的载体，buffer是存储数据的地方，线程每次从buffer检查数据通知给通道

        5）处理数据的线程数
           NIO：一个线程管理多个连接
           BIO：一个线程管理一个连接

    1.4 NIO简介
    在Java1.4之前的I/O系统中，提供的都是面向流的I/O系统，系统一次一个字节地处理数据，一个输入流产生一个字节的数据，
    一个输出流消费一个字节的数据，面向流的I/O速度非常慢，而在Java 1.4中推出了NIO，这是一个面向块的I/O系统，系统以块
    的方式处理处理，每一个操作在一步中产生或者消费一个数据块，按块处理要比按字节处理数据快的多。

    1.5 缓冲区Buffer
        缓冲区实际上是一个容器对象，更直接的说，其实就是一个数组，在NIO库中，所有数据都是用缓冲区处理的。在读取数据时，
        它是直接读到缓冲区中的； 在写入数据时，它也是写入到缓冲区中的；任何时候访问 NIO 中的数据，都是将它放到缓冲区
        中。而在面向流I/O系统中，所有数据都是直接写入或者直接将数据读取到Stream对象中。

        1）其中的四个属性的含义分别如下：
        容量（Capacity）：缓冲区能够容纳的数据元素的最大数量。这一个容量在缓冲区创建时被设定，并且永远不能改变。
        上界(Limit)：缓冲区的第一个不能被读或写的元素。或者说,缓冲区中现存元素的计数。
        位置(Position)：下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。
        标记(Mark)：下一个要被读或写的元素的索引。位置会自动由相应的 get( )和 put( )函数更新。

        2）Buffer的常见方法如下所示:
        flip(): 写模式转换成读模式
        rewind()：将 position 重置为 0 ，一般用于重复读。
        clear() ：
        compact(): 将未读取的数据拷贝到 buffer 的头部位。
        mark(): reset():mark 可以标记一个位置， reset 可以重置到该位置。
        Buffer 常见类型： ByteBuffer 、 MappedByteBuffer 、 CharBuffer 、 DoubleBuffer 、 FloatBuffer 、 IntBuffer 、 LongBuffer 、 ShortBuffer 。

        3）基本操作
        Buffer基础操作： 链接
        缓冲区分片，缓冲区分配，直接缓存区，缓存区映射，缓存区只读：链接

        4）缓冲区存取数据流程
        存数据时position会++，当停止数据读取的时候
        调用flip()，此时limit=position，position=0
        读取数据时position++，一直读取到limit
        clear() 清空 buffer ，准备再次被写入 (position 变成 0 ， limit 变成 capacity) 。

    1.6.通道Channel
        通道是一个对象，通过它可以读取和写入数据，当然了所有数据都通过Buffer对象来处理。我们永远不会将字节直接写入通道中
        ，相反是将数据写入包含一个或者多个字节的缓冲区。同样不会直接从通道中读取字节，而是将数据从通道读入缓冲区，再
        从缓冲区获取这个字节。
        在NIO中，提供了多种通道对象，而所有的通道对象都实现了Channel接口

        1）使用NIO读取数据
        在前面我们说过，任何时候读取数据，都不是直接从通道读取，而是从通道读取到缓冲区。所以使用NIO读取数据可以
        分为下面三个步骤：

        从FileInputStream获取Channel
        创建Buffer
        将数据从Channel读取到Buffer中
        例子：链接
        2）使用NIO写入数据
        使用NIO写入数据与读取数据的过程类似，同样数据不是直接写入通道，而是写入缓冲区，可以分为下面三个步骤：

        从FileOutputStream获取Channel
        创建Buffer
        将数据从Channel写入到Buffer中

    1.7 反应堆(Reactor)
       1）阻塞IO模型
       在老的IO包中，serverSocket和socket都是阻塞式的，因此一旦有大规模的并发行为，而每一个访问都会开启一个新线程。
       这时会有大规模的线程上下文切换操作（因为都在等待，所以资源全都被已有的线程吃掉了），这时无论是等待的线程还是
       正在处理的线程，响应率都会下降，并且会影响新的线程。

       2）NIO
       Java NIO是在jdk1.4开始使用的，它既可以说成“新IO”，也可以说成非阻塞式I/O。下面是java NIO的工作原理：
       1.由一个专门的线程来处理所有的IO事件，并负责分发。
       2.事件驱动机制：事件到的时候触发，而不是同步的去监视事件。
       3.线程通讯：线程之间通过wait,notify等方式通讯。保证每次上下文切换都是有意义的。减少无谓的线程切换。

       注：每个线程的处理流程大概都是读取数据，解码，计算处理，编码，发送响应

    1.8 选择器（Selector）
        传统的 server / client 模式会基于 TPR ( Thread per Request ) ．服务器会为每个客户端请求建立一个线程．
        由该线程单独负责处理一个客户请求。这种模式带来的一个问题就是线程数量的剧增．大量的线程会增大服务器的开销，
        大多数的实现为了避免这个问题，都采用了线程池模型，并设置线程池线程的最大数量，这又带来了新的问题，如果
        线程池中有 200 个线程，而有 200 个用户都在进行大文件下载，会导致第 201 个用户的请求无法及时处理，即便第
         201 个用户只想请求一个几 KB 大小的页面

         NIO 中非阻塞IO采用了基于Reactor模式的工作方式，IO调用不会被阻塞，相反是注册感兴趣的特点IO事件，如可读
         数据到达，新的套接字等等，在发生特定事件时，系统再通知我们。 NlO中实现非阻塞IO的核心设计Selector，
         Selector就是注册各种IO事件的地方，而且当那些事件发生时，就是这个对象告诉我们所发生的事件。

         当有读或者写等任何注册的事件发生时，可以从Selector中获得相应的SelectionKey，同时从SelectionKey中可以找到
         发生的事件和该事件所发生的具体的SelectableChannel，以获得客户端发送过来的数据。

         使用NIO中非阻塞IO编写服务器处理程序，有三个步骤
         1.向Selector对象注册感兴趣的事件
         2.从Selector中获取感兴趣的事件
         3.根据不同事件进行相应的处理


二：netty
    netty其实是对 NIO 使用的封装，是完全基于 NIO 实现的，整个 netty 都是异步的
        2.1：NIO 的通信步骤；
            1>创建 ServerSocketChannel,为其配置非阻塞模式
            2>绑定监听，配置 TCP 参数，录入 backlog 大小等
            3>创建一个独立的 IO线程，用于轮询多路复用器 Selector
            4>创建 Selector,将之前创建的 ServerSocketChannel 注册到 Selector 上，并设置监听标识位：
                SelectionKey.OP_ACCEPT
            5>启动 io 线程，在循环体中执行 Selector.select() 方法，轮询就绪的通道
            6>当轮询到处于就绪状态的通道时，需要进行操作位判断，如果是 ACCEPT 状态，说明是新的客户端接入，则调用
                accept方法接收新的客户端
            7>设置新接入客户端的一些参数，如 非阻塞，并将其继续注册到 Selector 上，设置监听标识位等。
            8>如果轮询的通道标识位是 READ ，则进行读取，构造 Buffer 对象等。
            9>更细节的问题还有数据没发送完成继续发送的问题.

        2.2:netty 通信步骤
            1>创建两个 NIO 线程组，一个专门用于网络事件处理（接收客户端的连接），另一个则进行网络通信的读写
            2>创建一个 ServerBootstrap 对象，配置 netty 的一系列参数，例如接收传出数据的缓存大小等
            3>创建一个用于实际处理数据的类 ChannelInitializer ,进行初始化的准备工作，比如设置接收传出数据
                的字符集、格式以及实际处理数据的接口
            4>绑定端口，执行同步阻塞方法等待服务器端启动即可


        2.3. 高性能的三个主题
        1) 传输（IO模型）：用什么样的通道将数据发送给对方，BIO、NIO或者AIO，IO模型在很大程度上决定了框架的性能。
        2) 协议（数据协议）：采用什么样的通信协议，HTTP或者内部私有协议。协议的选择不同，性能模型也不同。相比于
            公有协议，内部私有协议的性能通常可以被设计的更优。
        3) 线程（线程模型）：数据如何读取？读取之后的编解码在哪个线程进行，编解码后的消息如何派发，Reactor线程
            模型的不同，对性能的影响也非常大。

        Netty的IO线程NioEventLoop由于聚合了多路复用器Selector，可以同时并发处理成百上千个客户端Channel，由于读写
        操作都是非阻塞的，这就可以充分提升IO线程的运行效率，避免由于频繁IO阻塞导致的线程挂起。另外，由于Netty采用
        了异步通信模式，一个IO线程可以并发处理N个客户端连接和读写操作，这从根本上解决了传统同步阻塞IO一连接一线程
        模型，架构的性能、弹性伸缩能力和可靠性都得到了极大的提升。


        2.4. 零拷贝
        Netty的“零拷贝”主要体现在如下三个方面：

        1) Netty的接收和发送ByteBuffer采用DIRECT BUFFERS，使用堆外直接内存进行Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行Socket读写，JVM会将堆内存Buffer拷贝一份到直接内存中，然后才写入Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。

        2) Netty提供了组合Buffer对象，可以聚合多个ByteBuffer对象，用户可以像操作一个Buffer那样方便的对组合Buffer进行操作，避免了传统通过内存拷贝的方式将几个小Buffer合并成一个大的Buffer。

        3) Netty的文件传输采用了transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环write方式导致的内存拷贝问题。
        （map的buffer）


        2.6. 高效的Reactor线程模型
        常用的Reactor线程模型有三种，分别如下：
        1) Reactor单线程模型；
        2) Reactor多线程模型；
        3) 主从Reactor多线程模型

        Reactor单线程模型，指的是所有的IO操作都在同一个NIO线程上面完成，NIO线程的职责如下：
        1) 作为NIO服务端，接收客户端的TCP连接；
        2) 作为NIO客户端，向服务端发起TCP连接；
        3) 读取通信对端的请求或者应答消息；
        4) 向通信对端发送消息请求或者应答消息。

        Reactor多线程模型的特点：

        1) 有专门一个NIO线程-Acceptor线程用于监听服务端，接收客户端的TCP连接请求；
        2) 网络IO操作-读、写等由一个NIO线程池负责，线程池可以采用标准的JDK线程池实现，它包含一个任务队列和N个可用
            的线程，由这些NIO线程负责消息的读取、解码、编码和发送；
        3) 1个NIO线程可以同时处理N条链路，但是1个链路只对应1个NIO线程，防止发生并发操作问题。
            在绝大多数场景下，Reactor多线程模型都可以满足性能需求；但是，在极特殊应用场景中，一个NIO线程负责监听和处理所有的客户端连接可能会存在性能问题。例如百万客户端并发连接，或者服务端需要对客户端的握手消息进行安全认证，认证本身非常损耗性能。在这类场景下，单独一个Acceptor线程可能会存在性能不足问题，为了解决性能问题，产生了第三种Reactor线程模型-主从Reactor多线程模型。
        主从Reactor线程模型的特点是：服务端用于接收客户端连接的不再是个1个单独的NIO线程，而是一个独立的NIO线程池。
        Acceptor接收到客户端TCP连接请求处理完成后（可能包含接入认证等），将新创建的SocketChannel注册到IO线程池
        （sub reactor线程池）的某个IO线程上，由它负责SocketChannel的读写和编解码工作。Acceptor线程池仅仅只用于客户端
        的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端subReactor线程池的IO线程上，由IO线程负责后续的
        IO操作。






