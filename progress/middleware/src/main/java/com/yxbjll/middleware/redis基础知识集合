一：哨兵模式和集群（参考文档：http://www.360doc.com/content/19/0405/18/25472797_826634296.shtml）
    1.1：主从模式
        redis的主从模式类似mysql的主从，配置主从后，数据从主写入，每隔一段时间从节点会同步主节点的数据，
        这样就实现了高可用。但是如果主节点故障，此时需要手动去将从节点切换为主节点，不会自动切换，不能
        实现自动化。利用主从可以实现读写分离，提高读写性能

    1.2：哨兵模式（redis-sentinel）
        哨兵模式主要解决了主从模式下，主节点故障后，不会自动切换可用节点的问题。哨兵模式在主从上，新增
        哨兵节点，通过哨兵来监控各节点的运行情况，服务是否可用。如果一个哨兵发现一个服务不可用，此时该
        哨兵主观认为服务下线，此时叫做主观下线，然后其他节点也会检测该服务，超过一定数量的哨兵都认为此
        服务故障后，就会认为此服务已下线。此时叫做客观下线。这时哨兵集群会选举出一个新的主节点来提供服
        务。因此哨兵也需要进行集群部署

        节点选取规则：
        数量最少为3台。因为选举成功的条件是超过半数的节点同意才可切换。
        如果两台服务，那么此时至少要1+1 = 2的同意才可，但此时一台坏了，就只有一台，此时不能选举。如果
        三台，一半为 1.5，那么此时剩下两台都同意，即大于 1.5，此时可以。关于为什么服务数量为 奇数 而不
        是偶数的原因：三台和四台，三台需要两台同意，一台故障，而四台的时候，最少要 2+1 = 3 台才可以进
        行选举，那么也是只允许一条故障，此时奇数下效果一样，但是节省服务器资源(一个sentinel节点会监控所有
        的redis实例运行情况)

        注：下线判断有两种：
        配置文件中配置的数目和当前sentinel节点集合数的一半，这里两个数目的较大值。不仅仅是超过半数sentinel
        同意而已

    1.3：集群模式
        集群是redis客户端自带的分片分布式。通过自己内部的监控来进行节点切换，同时便于分布式存储（通过
        slot槽来对数据进行分区，类似一致性hash），解决了单机内存、并发、流量等问题。另一方面：解决了
        sentinel节点下，如果是从节点下线了，sentinel是不会对其进行故障转移的，并且连接从节点的客户端
        也无法获取到新的可用从节点.


二：配置
    2.1：主从配置（一主两从）
        修改redis.conf文件：

            主机6379的主要配置：
            bind 127.0.0.1
            port 6379
            logfile '6379.log'
            dbfilename 'dump-6379.rdb

            从机6380和6381的配置：
            bind 127.0.0.1
            port 6380
            logfile '6380.log'
            dbfilename 'dump-6380.rdb'
            slaveof 127.0.0.1 6379（slaveof 表示是某节点的从节点）

            bind 127.0.0.1
            port 6381
            logfile '6381.log'
            dbfilename 'dump-6381.rdb'
            slaveof 127.0.0.1 6379



三：基础知识总结
    3.1：缓存雪崩
         缓存服务器宕机，此时并发太大，都打到数据库。导致数据库挂掉。重启数据库也一样。这就是缓存雪崩

         解决方案：
            3.1.1:事前 redis高可用，主从+哨兵 ，redis cluster,避免全盘崩溃
            3.1.2:事中 本地 ehcache 缓存 + 限流&降级
            3.1.3:redis持久化，一旦重启，自动从磁盘上加载数据，加快恢复缓存数据

    3.2：缓存穿透
         一个系统，一秒 5000请求， 4000是恶意攻击。并且缓存中查不到（比如 id 负数），此时就会去数据库查询
         导致数据库被打死

         解决方案：
             每次系统 A 从数据库中只要没查到，就写一个空值到缓存里去，比如 set -999 UNKNOWN。然后
             设置一个过期时间，这样的话，下次有相同的 key 来访问的时候，在缓存失效之前，都可以直接从缓存中取数据

    3.3：缓存击穿
         某个key非常热点，访问非常频繁，当这个key失效瞬间，会有大量请求击穿缓存，直接请求数据库。

         解决方案：
            若缓存的数据是基本不会发生更新的，则可尝试将该热点数据设置为永不过期。
    综上所述，使用redis正确的方式为： --->内存 --->redis --->数据库  这种三层架构


四：redis 五种数据类型
    4.1：String   key-value
    4.2: Hash     key-field-value
    4.3: List     可以作为队列，但是要注意加锁  有顺序可重复，取完值会删除，如 lpop list 从左删除
                  lpush runoob redis   lrange runoob 0 10
    4.4: Set      无顺序，不能重复   sadd runoob redis    smembers runoob
    4.5: Zset(sorted set 有序集合)，每个元素都会关联一个double 类型分数，redis通过分数来为集合中的成员进行
                  从小到大的排序  zadd key score member   zadd runoob 0 redis
