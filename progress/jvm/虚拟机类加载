一：类加载概念：
        1.1：虚拟机将描述类的数据从class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用
             的java类型，这就是虚拟机的类加载机制

        1.2：类加载的时机
             类从被虚拟机加载到内存开始，到卸载出内存为止，整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载
             七个阶段。其中验证、准备、解析三个部分统称为 连接

             加载、验证、准备、初始化和卸载五个阶段顺序是确定的，但解析阶段不一定，某些情况下可以在初始化阶段之后再开始。
             这是为了支持java语言的运行时绑定（动态绑定或者晚期绑定）这些阶段通常都是交叉混合进行的，会在一个过程中调用
             或激活另外一个阶段

             立即对类初始化的有且仅有的四种情况：
                1.遇到new、getStatic、putStatic(读取或设置一个类的静态字段时候(除final修饰的static外)、invokeStatic(调用类的静态方法)
                2.使用java.lang.reflect包的方法对类进行反射调用，如果类没有进行初始化，需先触发初始化
                3.初始化一个类，其父类没有进行初始化，触发父类的初始化
                4.虚拟机启动时，用户需要指定一个要执行的主类，（包含main方法的那个类），虚拟机会先初始化这个类

             接口的加载过程与类加载过程稍微不同，针对接口；
                接口也有初始化过程，与类一致，编译期会为接口生成“<clinit>()”类构造器，用于初始化接口中所定义的成员变量。
                接口初始化与类加载唯一不同就是，接口在初始化时，并不要求父类接口全部完成了初始化，只有在真正使用到父接口
                的时候，（如引用接口中定义的常量）才会初始化

        1.3：类加载过程
             1.3.1:加载
                加载阶段：此过程虚拟机要完成以下三件事情：
                    1）通过一个类的全限定名来获取定义此类的二进制字节流
                    2）将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构（1.8中方法区已变为元空间，存放在堆上）
                    3）在java堆中生成一个代表这个类的java.lang.Class对象，作为方法区（堆）这些数据的访问入口
                    加载完成后，虚拟机外部的二进制字节流就按照虚拟机所需的格式存储在(元空间？堆？)上，数据存储格式自行定义，加载阶段
                    与连接阶段有一部分是交叉的（一部分字节码文件格式验证）

             1.3.2：验证
                验证是为了确保当前Class文件的字节流中的信息符合虚拟机的要求，大致有4个阶段的检验过程：
                    1）文件格式验证
                        验证字节流是否符合Class文件格式的规范，并且能被当前版本虚拟机处理：
                            是否以魔数 0xCAFEBABE开头；主次版本号是否在当前虚拟机处理范围之内；常量池的常量中是否有不被支持
                            的常量类型；
                        该阶段的验证
                    2）元数据校验
                        对字节码描述的信息进行语义分析，如：
                            这个类是否有父类、父类是否继承了不允许被继承的类（被final修饰的类）。。。。。
                    3）字节码校验
                        保证跳转指令不会跳转到方法体以外的字节码指令上
                    4）符号引用验证
                        最后一个阶段的验证发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三个阶段---解析阶段中发生
                        符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的信息进行匹配性的校验，如：
                            符号引用中通过字符串描述的全限定名是否能找到对应的类
             1.3.3：准备
                准备阶段是正式为类变量分配内存并设置类变量初始值的阶段。内存都在方法区（现为元空间？堆？）中进行分配。
                1）该阶段进行内存分配的仅包括类变量（被static修饰的变量），不包括实例变量(成员变量)，实例变量将会在对象实例化时随着对象一起分配
                   在java堆中，在堆中为.class的类变量开辟内存；堆中的地址存放于栈以便高速访问

                2）这里的初始值，通常情况下是数据类型的零值，假设一个变量定义为：
                    public static int value = 123;
                    那么变量在准备阶段过后的初始值通常为0，而不是123，因为这时候尚未执行任何java方法，而把value赋值为123的 putstatic
                    指令，将在初始化阶段才会执行。特殊情况：如果类字段的字段属性表中存在 ConstantValue 属性，那么准备阶段，value就会
                    被初始化为 ConstantValue 属性所指定的值，如：
                        public static final int value = 123;
                        编译时javac将会为value生成 ConstantValue属性，在准备阶段，虚拟机根据 ConstantValue的设置将value赋值为123



             1.3.4：解析
                解析阶段是将常量池内的符号引用替换为直接引用的过程，符号引用在 Class文件中以 CONSTANT_Class_info、CONSTANT_Fieldref_info。
                CONSTANT_Methodref_info等类型的常量出现
                    符号引用：
                        是以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要能无歧义的定位到目标即可。引用的目标不一定已经加载
                        到内存中。
                    直接引用:可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，如果有直接引用，那么一定存在内存中

                    解析动作主要针对 类或接口、字段、类方法、接口方法四类符号引用进行，分别对应与常量池的
                        CONSTANT_Class_info、CONSTANT_Fieldref_info、CONSTANT_Methodref_info 及
                        CONSTANT_InterfaceMethodref_info

                     1）类或接口的解析：
                        如果当前代码所处的类为D,如果要把一个从未解析过的符号运用 N解析为一个类或者接口C的直接引用，
                        那么虚拟机完成解析的过程包括3个步骤：
                            1.1：如果C不是一个数组类型，那么虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C，
                                在加载过程中， 由于无数据验证，字节码验证的需要，又将可能触发其它相关类的加载动作。例如
                                加载这个类的父类或实现的接口，一旦这个加载过程出现了异常，解析过程就宣告失败
                            1.2：如果C是一个数组类型，并且数组元素类型为对象，也就是N的描述符会是类似"[Ljava.lang.Integer"的
                                形式，那将会按照1.1的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载
                                的元素类型就是"java.lang.Integer",接着由虚拟机生成一个代表此数组维度和元素的数组对象
                            1.3：如果上面的步骤没有出现异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在
                                解析完成之前，还要进行符号引用验证，确认C是否具备对D的访问权限，不具备会报：IllegalAcccessError
                                异常

                     2）字段解析：
                        要解析一个未被解析过的字段符号引用，首先会对字段表内的 class_index 项中索引的 CONSTANT_Class_info
                        符号引用进行解析，也就是字段所属的类或接口的符号引用。如果在解析这个类或者符号引用的过程中异常，
                        会导致字段符号引用解析的失败，解析成功，这个字段所属的类或者接口用C表示，后续需进行以下步骤：
                            2.1：如果C本身包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查
                                找结束
                            2.2：否则，如果在C中实现了接口，将会按照继承关系从上往上递归搜索各个接口和它的父接口，如果接口
                                中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用
                            2.3：否则，如果C不是java.lang.Object的话，将会按照继承关系从上往下递归搜索其父类。如果在父类
                                包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束
                            2.4：否则，查找失败，抛出java.lang.NoSuceFieldError异常

                     3）类方法解析：
                        类方法解析的第一个步骤和字段解析一样，也是需要先解析出类方法表的class_index项中索引的方法所属的类或
                        接口的符号引用，如果成功，依然用C表示这个类，接下步骤：
                            3.1：类方法和接口方法符号引用的常量类型定义是分开的，如果在类方法表中发现class_index中索引的C是
                                个接口，那么直接抛出 java.lang.IncompatibleClassChangeError异常
                            3.2：通过3.1，在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个类的直接引用，
                                查找结束
                            3.3：否则，在类C的父类中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的
                                直接引用，查找结束
                            3.4：否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，
                                如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出java.lang.AbstractMethodError异常
                            3.5：否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError

                            最后，如果查找过程成功返回了直接引用，将会对这个方法进行权限验证，如果发现不具备对此方法的访问权限，
                                将抛出java.lang.IllegalAccessError异常

                     4）接口方法解析：
                        接口方法也是需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然
                        用C表示这个接口
                            4.1：与类方法解析相反，如果在接口方法表中发现class_index中的索引C是个类而不是借口，直接抛出java.lang.
                                IncompatibleClassChangeError异常
                            4.2：否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找
                                结束
                            4.3：否则，在接口C的父接口中递归查找，直到java.lang.object类（查找范围会包括Object类）为止，看是否有简单
                                名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束
                            4.4：否则，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常
                        由于接口中的所有方法都默认public的，所以不存在访问权限的问题，因此接口方法的符号解析应当不会抛出IllegalAccess
                        Error异常

             1.3.5：初始化
                初始化是类加载的最后一步，到了初始化阶段，才真正开始执行类中定义的java代码（或者说字节码）
                在准备阶段，变量已经赋过一次系统要求的初始值，而在初始化阶段，则是根据程序指定的主观计划去初始化类变量和其他资源。或者
                另一角度表达：初始化阶段是执行类构造器<clinit>() 方法的过程。

                <clinit>() 介绍：
                    是由编译器自动收集类中所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的。编译器收集的
                    顺序是由语句在源文件中出现的顺序所决定的，静态语句块中只能访问到定义的在静态语句块之前的变量，定义在它之后的变量，在前面
                    的静态语句快中可以赋值，但是不能访问

                    <clinit>()方法与类的构造函数（或者说实例构造器<init>()方法）不同，它不需要显示的调用父类构造器，虚拟机会保证在子类
                    的<clinit>()方法执行之前，父类的<clinit>()方法已经执行完毕。因此在虚拟机中，第一个执行<clinit>()方法的类肯定是
                    java.lang.Object

                    由于父类的<clinit>()方法先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作
                    如：父类中：
                        public static int A = 1;
                        static{
                            A=2;
                        }

                        子类中：
                        public static int B=A;
                        此时输出 子类中的B，为 B=2

                    <clinit>()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句块，也没有对变量的赋值操作，那么编译器可以不为
                    这个类生成<clinit>()方法。
                    接口中不能使用静态语句块，但仍然有变量初始化的赋值操作，因此接口与类一样都会生成<clinit>()方法，但接口与类不同，执行
                    接口的<clinit>()方法不需要先执行父接口的<clinit>()方法，只有当父接口中定义的变量被使用时，父接口才会被初始化，另外，
                    接口的实现类在初始化时，也不会执行接口的<clinit>()方法

                    虚拟机会保证一个类的<clinit>()方法在多线程环境中被正确的加锁和同步，多个线程初始化一个类，只会有一个线程去执行这个类
                    的<clinit>()方法，其他线程都会阻塞等待




    总结：一个class加载过程描述
        在编译好java程序得到MainApp.class文件后，在命令行上敲java AppMain。系统就会启动一个jvm进程，jvm进程从classpath路径中找到一个
        名为AppMain.class的二进制文件，将MainApp的类信息加载到运行时数据区的方法区内，这个过程叫做MainApp类的加载。
        然后JVM找到AppMain的主函数入口，开始执行main函数。

        main函数的第一条命令是Animal animal = new Animal("Puppy");就是让JVM创建一个Animal对象，但是这时候方法区中没有Animal类的信息，
        所以JVM马上加载Animal类，把Animal类的类型信息放到方法区中。
        加载完Animal类之后，Java虚拟机做的第一件事情就是在堆区中为一个新的Animal实例分配内存，然后调用构造函数初始化Animal实例，这个
        Animal实例持有着指向方法区的Animal类的类型信息（其中包含有方法表，java动态绑定的底层实现）的引用。
        当使用animal.printName()的时候，JVM根据animal引用找到Animal对象，然后根据Animal对象持有的引用定位到方法区中Animal类的类型信息
        的方法表，获得printName()函数的字节码的地址。
        开始运行printName()函数的字节码（可以把字节码理解为一条条的指令）。

        特别说明：java类中所有public和protected的实例方法都采用动态绑定机制，所有私有方法、静态方法、构造器及初始化方法<clinit>都是
        采用静态绑定机制。而使用动态绑定机制的时候会用到方法表，静态绑定时并不会用到。


二：虚拟机字节码执行引擎







