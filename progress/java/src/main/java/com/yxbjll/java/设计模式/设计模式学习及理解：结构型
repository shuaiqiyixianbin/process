一：适配器模式：
    是作为两个不兼容的接口之间的桥梁。这种类型的设计模式属于结构型模式，它结合了两个独立接口的功能。这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。
   
    举例：
        1.读卡器是作为内存卡和笔记本之间的适配器。将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔
        记本来读取内存卡。 2.java中的jdbc（只要输入数据库名如 mysql或者oracle，jdbc底层就会自动适配类型
        ，执行方法）

  意图：将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些
        类可以一起工作。

  主要解决：在软件系统中，常常要将一些"现存的对象"放到新的环境中，而新环境要求的接口是现对象不能满足的。
        需要通过接口转换，将一个类插入到另一个类系中。继承或依赖。

  代码案例：
        一个音频播放器现在要通过适配器来进行视频以及vlc的播放。
       MediaPlayer 是原本用于播放音频的类，AdvancedMediaPlayer是用于 Vlc以及 Mp4的类

  总结：AudioPlayer是MediaPlayer的实现类，也就是具体管理播放的类，以前只有 play()方法，现在要能播放其他
         类型的，因此要传入类型，判断，如果是音频就和以前一样，如果是视频或者Vlc的话，就使用适配器来进行
         初始化（适配器会传入具体类型，然后实例化对应的类，返回类之后，就调用对应的play()方法），因此操作
         都是在AudioPlayer类中，因为它是具体的执行类。此时适配器里面也要进行类的封装（通过传入的类型，实
         例化对应的实现类。然后里面的方法要和AudioPlayer的play()方法一致，但本质上还是具体的类的方法。）
         ，因为要实现和AudioPlayer同样的功能，因此也要实现MediaPlayer这样才能一致化。

  理解：也就是说 Adapter的核心就是工厂模式，在内部通过类型的判断，生成对应的实现类（操作类），然后封装了
         和原先的实现类相同的实现方法名，用于维持一致性。这样在AudioPlayer内部引用Adapter,实现原来没有的
         功能。本质上适配器模式就是把两个不相关的接口，通过继承实现依赖（中间类），引入需要新增的类的功能。

二：过滤器：
    过滤器模式或标准模式（Criteria Pattern），允许开发人员使用不同的标准来过滤一组对象，通过逻辑
    运算以解耦的方式把它们连接起来。结合多个标准来获得单一标准。

  代码实现：
     在类中实现方法，进行类型判断过滤：
 测试方法：
 总结：过滤模式就是通过实现一个类，然后在各个实现类中进行类型的判断，然后返回对应的过滤后的合法数据。因此，是非常常见的一种（平时对数据库返回的数据进行类型过滤后返回需要的值就是如此操作）
   java8 中具体实现：

三：代理模式（proxy pattern）:
    一个类代表（代理）另一个类的功能，属于结构型模式。我们创建（内部）具有现有对象的对象，以便向外界提供
    功能接口。

  意图：为其他对象提供一种代理以控制对这个对象的访问。
     主要解决：直接访问对象时带来的问题，如 某些操作需要安全控制，或者需要进程外的访问，直接访问会给使用者或者系统结构带来很多麻烦，此时可以在访问此对象时加上一个对此对象的访问层，相当于中间介质。
     何时使用：想在访问一个类时做一些控制。解决：增加中间层。
     应用实例：买火车票不一定要在火车站买。以及：一张支票或者银行存单是账户中资金的代理，在市场交易中用来代替现金，并提供对签发人账号上资金的控制。以及 spring aop(事务中把整个方法当做一个代理，然后再前后进行事务操作)

  注意事项：
        1、和适配器的区别：适配器模式主要是改变所考虑对象的接口（使新增的适配器类实现原有接口，然后对其方法进行适配），而代理模式不能改变所代理类的接口。2、和装饰器模式的区别：装饰器模式是为了增强功能，而代理模式是为了加以控制。
     实现：

    和适配器模式相同的地方就是在新类中，都传入原来的对象（初始化原来的对象并进行方法的调用），因为实现了
    原有的接口，因此方法就是直接调用真实类的方法即可。功能还是一样，只不过是外面套了一层，减少直接操作，
    可以对一些信息进行隐藏（细节）

 拓展：JDK自带的动态代理：
     java.lang.reflect.proxy:生成动态代理类和对象。
     java.lang.reflect.InvocationHandler：可以通过invoke方法实现对真实角色的代理访问。
代理方式还有 CGLIB动态代理，一般spring默认为 jdk动态代理即可。